# Yet another way to keep track of visited node in bfs
加入队列 就代表走过，立刻标记，正确写法
超时写法 （从队列中取出节点再标记）
<img width="893" alt="image" src="https://github.com/ZhengLin-Li/Learning_Repo/assets/63448884/99ad418f-9da5-490b-9d18-45bf9d7bf5eb">


## Yet another way to understand backtrack and dfs
```java
// DFS 算法，关注点在节点
void traverse(TreeNode root) {
    if (root == null) return;
    printf("进入节点 %s", root);
    for (TreeNode child : root.children) {
        traverse(child);
    }
    printf("离开节点 %s", root);
}

// 回溯算法，关注点在树枝
void backtrack(TreeNode root) {
    if (root == null) return;
    for (TreeNode child : root.children) {
        // 做选择
        printf("从 %s 到 %s", root, child);
        backtrack(child);
        // 撤销选择
        printf("从 %s 到 %s", child, root);
    }
}
```


## Yet another way to add element to heap with size k

original way:
```java
        for (int key : numToFre.keySet()) {
            if (pq.size() < k) {
                pq.offer(key);
            } else {
                int value = numToFre.get(key);
                if (value > numToFre.get(pq.peek())) {
                    pq.poll();
                    pq.offer(key);
                }
            }
        }
```


optimized way:
```java
        for (Integer key : map.keySet()) {
            pq.offer(key);
            if (pq.size() > k) {
                pq.poll();
            }
        }
```

# Yet another way to eliminate duplicates in the same level but not same path

![image](https://github.com/ZhengLin-Li/Learning_Repo/assets/63448884/1bedc4ca-84ea-47d5-be55-7968e5ba6dc5)


Carl way:
```java
            // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
            // 要对同一树层使用过的元素进行跳过
            if (i - 1 >= 0 && candidates[i] == candidates[i - 1] && !used[i - 1])
                continue;
```

Labuladong way:
```java
            // 剪枝逻辑，值相同的树枝，只遍历第一条
            if (i > start && nums[i] == nums[i - 1]) {
                continue;
            }
```
