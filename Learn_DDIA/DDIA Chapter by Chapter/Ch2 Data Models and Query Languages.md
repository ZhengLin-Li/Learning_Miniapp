# 关系模型

当今最流行的数据库模型

特点如下：

- 将数据以关系呈现给用户（比如：一组包含行列的二维表）。
- 提供操作数据集合的关系算子。

常见分类：

- 事务型（TP）：银行交易、火车票
- 分析型（AP）：数据报表、监控表盘
- 混合型（HTAP）：

虽有不时有各种挑战者（网状模型 network model 和 层次模型 hierarchical model ），但始终仍未有根本的能撼动其地位

# NoSQL

NoSQL（Non-SQL，Not only SQL），是对不同于传统的关系数据库的数据库管理系统的统称

最受欢迎的 NoSQL 前几名为：MongoDB，Redis，ElasticSearch，Cassandra

其催动因素有：

- 处理更大数据集：更强伸缩性、更高吞吐量
- 开源免费的兴起：冲击了原来把握在厂商的标准
- 特化的查询操作：关系数据库难以支持的，比如图中的多跳分析
- 表达能力更强：关系模型约束太严，限制太多

# 多对一和多对多

## text or id?

region 在存储时，为什么不直接存储纯字符串：“Greater Seattle Area”，而是先存为 region_id → region name，其他地方都引用 region_id？

- 统一样式：所有用到相同概念的地方都有相同的拼写和样式
- 避免歧义：可能有同名地区
- 易于修改：如果一个地区改名了，我们不用去逐一修改所有引用他的地方
- 本地化支持：如果翻译成其他语言，可以只翻译名字表。
- 更好搜索：列表可以关联地区，进行树形组织

用 ID 还是文本? ID 对人类是无意义的，无意义的意味着不会随着现实世界的将来的改变而改动。

## duplication and normalization

在关系数据库表设计时需要考虑，即如何控制冗余（duplication）。会有几种范式（normalization） 来消除冗余。

文档型数据库很擅长处理一对多的树形关系，却不擅长处理多对多的图形关系。如果其不支持 Join，则处理多对多关系的复杂度就从数据库侧移动到了应用侧。

![](https://ddia.qtmuniao.com/img/ch02-fig02.png)

## 文档数据模型 vs 关系数据模型

- 对于一对多关系，文档型数据库将嵌套数据放在父节点中，而非单拎出来放另外一张表。
- 对于多对一和多对多关系，本质上，两者都是使用外键（文档引用）进行索引。查询时需要进行 join 或者动态跟随。

# 面向对象和关系模型的不匹配

核心冲突在于面向对象的嵌套性和关系模型的平铺性（？ => ORM 框架

关系模型很难直观的表示一对多的关系，比如简历上，一个人可能有多段教育经历和多段工作经历

- 文档模型：使用 Json 和 XML 的天然嵌套。
- 关系模型：使用 SQL 模型就得将职位、教育单拎一张表，然后在用户表中使用外键关联。

在简历的例子中，文档模型还有几个优势：

- 模式灵活：可以动态增删字段，如工作经历。
- 更好的局部性：一个人的所有属性被集中访问的同时，也被集中存储。
- 结构表达语义：简历与联系信息、教育经历、职业信息等隐含一对多的树状关系可以被 JSON 的树状结构明确表达出来。

# 层次模型 （hierarchical model）

特点：

- 树形组织，每个子节点只允许有一个父节点
- 节点存储数据，节点有类型
- 节点间使用类似指针方式连接

和文档模型很像，很难解决多对多的关系，不支持 Join

为了解决层次模型的局限，人们提出了各种解决方案，最突出的是：

- 关系模型
- 网状模型

# 网状模型（network model）

是 hierarchical model 的一种扩展：允许一个节点有多个父节点

多对一和多对多都可以由路径来表示。访问记录的唯一方式是顺着元素和链接组成的链路进行访问，这个链路叫访问路径 （access path）

# 关系模型

数据被组织成元组（tuples），进而集合成关系（relations）；在 SQL 中分别对应行（rows）和表（tables）

看起来更像表模型，为什叫关系模型？ 关系（relation）的说法来自集合论，表只是一种实现。

贡献在于提供了一种声明式的描述数据和构建查询的方法：相比网络模型，关系模型的查询语句和执行路径相解耦，查询优化器（Query Optimizer 自动决定执行顺序、你只需要在新的字段上建立一个索引），即将逻辑和实现解耦

# 文档型 vs 关系型

|            | 文档型                                                                                                                           | 关系型                                     |
| ---------- | -------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------ |
| 对应关系   | 数据有天然的一对多、树形嵌套关系，如简历。                                                                                       | 通过外键+ Join 可以处理 多对一，多对多关系 |
| 代码简化   | 数据具有文档结构，则文档模型天然合适，用关系模型会使得建模繁琐、访问复杂。但不宜嵌套太深，因为只能手动指定访问路径，或者范围遍历 | 主键，索引，条件过滤                       |
| Join 支持  | 对 Join 支持的不太好                                                                                                             | 支持的还可以，但 Join 的实现会有很多难点   |
| 模式灵活性 | 弱 schema，支持动态增加字段                                                                                                      | 强 schema，修改 schema 代价很大            |
| 访问局部性 | 1. 一次性访问整个文档，较优 <br/>2. 只访问文档一部分，较差                                                                       | 分散在多个表中                             |

# 文档模型中的 Schema

schemaless 不太准确，更贴切的应该是 schema-on-read

| 数据模型        |                                        | 编程语言 |                    | 性能 & 空间                                                            |
| --------------- | -------------------------------------- | -------- | ------------------ | ---------------------------------------------------------------------- |
| schema-on-read  | 写入时不校验，而在读取时进行动态解析。 | 弱类型   | 动态，在运行时解析 | 读取时动态解析，性能较差。写入时无法确定类型，无法对齐空间利用率较差。 |
| schema-on-write | 写入时校验，数据对齐到 schema          | 强类型   | 静态，编译时确定   | 性能和空间使用都较优。                                                 |

# 局部性

同时需要文档中所有内容，把文档模型顺序存会效率比较高

只需要访问文档中的某些字段，则文档模型仍需要将文档全部加载出

# 关系型和文档型的融合

MySQL 和 PostgreSQL 开始原生支持 JSON

科德（Codd）：nonsimple domains，记录中的值除了简单类型（数字、字符串），还可以一个嵌套关系（表）。这很像 SQL 对 XML、JSON 的支持。

# 数据查询语言

|          | 声明式（declarative）语言                                       | 命令式（imperative）语言                                                   |
| -------- | --------------------------------------------------------------- | -------------------------------------------------------------------------- |
| 概念     | 描述控制逻辑而非执行流程                                        | 描述命令的执行过程，用一系列语句来不断改变状态                             |
| 举例     | SQL，CSS，XSL                                                   | IMS，CODASYL，通用语言如 C，C++，JS                                        |
| 抽象程度 | 高                                                              | 低                                                                         |
| 解耦程度 | 与实现解耦。 <br/>可以持续优化查询引擎性能；                    | 与实现耦合较深。                                                           |
| 解析执行 | 词法分析 → 语法分析 → 语义分析 <br/>生成执行计划 → 执行计划优化 | 词法分析 → 语法分析 → 语义分析 <br/>中间代码生成 → 代码优化 → 目标代码生成 |
| 多核并行 | 声明式更具多核潜力，给了更多运行时优化空间                      | 命令式由于指定了代码执行顺序，编译时优化空间较小。                         |
| 表达能力 | 粗粒度                                                          | 细粒度                                                                     |

# MapReduce 查询

- 借鉴自函数式编程。
- 一种相当简单的编程模型，或者说原子的抽象，**现在不太够用**。

# 图模型

基本概念一般有三个：点，边和附着于两者之上的属性

文档模型的适用场景？ 大量一对多（one-to-many）的关系。
图模型的适用场景？ 多对多（many-to-many）的关系。

| 例子     | 建模                        | 应用                   |
| -------- | --------------------------- | ---------------------- |
| 社交图谱 | 人是点， follow 关系是边    | 六度分隔，信息流推荐   |
| 互联网   | 网页是点，链接关系是边      | PageRank               |
| 路网     | 交通枢纽是点，铁路/公路是边 | 路径规划，导航最短路径 |
| 洗钱     | 账户是点，转账关系是边      | 判断是否有环           |
| 知识图谱 | 概念时点，关联关系是边      | 启发式问答             |

对图的建模方式

- 属性图（PG，Property Graphs）
- 三元组（triple-store）

# TODO
